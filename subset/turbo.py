#!/usr/bin/env python

from decimal import Decimal

def _return_width_list(num):  # _return_width_list()[0] <- for interleave, ~[1] <- for deinterleave
    i = 1
    while True:
        if (i**2 <= num) & (num < (i+1)**2):
            if num % i:
                return [i, (num // i) + 1]
            else:
                return [i, num // i]
        if i == 1000:
            print('ERROR:subsets._return_width: number of bits is too big.')
            return 'ERROR:subsets._return_width: number of bits is too big.'
        i += 1

def interleaver(lists, option):  # lists: [1,2,3]
    width = _return_width_list(len(lists))  # _return_width_list()[0] <- for interleave, ~[1] <- for deinterleave

    if option == 'interleave':
        while len(lists) % width[0]:
            lists.append(None)
    else:  # option == 'deinterleave'
        if len(lists) % width[1]:
            tmp = list()
            cnt_enough = len(lists) % width[0]
            cnt_not_enough = 0
            for cnt, l in enumerate(lists):
                if cnt_enough:
                    tmp.append(l)
                    if not (cnt+1) % width[1]:
                        cnt_enough -= 1
                else:
                    tmp.append(l)
                    cnt_not_enough += 1
                    if cnt_not_enough == (width[1] - 1):
                        tmp.append(None)
                        cnt_not_enough = 0
            lists = tmp

    result = list()
    width = width[option=='deinterleave']
    for i in range(width):
        for j in range(len(lists) // width):
            if not lists[width*j + i] == None:
                result.append(lists[width*j + i])
    return result
########## Usage ##########
#lists = list(range(12))  # [0,2,...,11]
#lists = interlerver(lists, 'interleave')  # [0, 3, 6, 9, 1, 4, 7, 10, 2, 5, 8, 11]
#lists = interlerver(lists, 'deinterleave')  # [0,1,...,11]

def return_code_and_next_state(value, state, option='-1to1'):  # code means parity
    if option == '-1to1':
        value = int((value+1)/(Decimal('2')))
    internal_list = [
            [[0,0], [1,2]],  # [ [code, next_state](if value == 0), [code, next_state](if value == 1) ](for S1)
            [[0,2], [1,0]],
            [[1,3], [0,1]],
            [[1,1], [0,3]]
            ]

    if option == '-1to1':  # convert: 0 -> -1, 1 -> 1
        return Decimal(internal_list[state][value][0])*2 - 1, internal_list[state][value][1]  # code, next_state
    else:  # no conversion(0->0, 1->1)
        return internal_list[state][value][0], internal_list[state][value][1]  # code, next_state

def generator_return_state(paths, option='-1to1'):  # generates state of paths
    # paths: [Decimal('-1'), Decimal('-1'), Decimal('-1'), Decimal('1'), Decimal('1'), Decimal('1'), Decimal('-1'), Decimal('-1'), Decimal('-1')]
    state = 0
    for path in paths:
        result, state = return_code_and_next_state(path, state, option='-1to1')  # result is not required
        yield state


def rsc_coder(str_input):

    code = str()  # hold a code generated by _return_code_and_next_state()
    state = 0
    result = str()
    for value in str_input:
        code, state = return_code_and_next_state(int(value), state, '0to1')
        result += str(code)
    return result

########## Usage ##########
#input_value = '00101'
#print(rsc_coder(input_value))  # '00110'

def puncture_code(code1, code2):  # code1: '11111', code2: '00000', result: '10101'
    flag = 0
    result = str()
    for codes in zip(code1, code2):
        result += codes[flag]
        flag = flag^1  # flag: 1->0, 0->1
    return result

def return_punctured_code(str_input):  # '01010'
    ########## for rsc coder 1 ##########
    code1 = rsc_coder(str_input)
    ########## for rsc coder 2 ##########
    code2 = rsc_coder(''.join(interleaver(list(str_input), 'interleave')))
    ########## puncture codes ##########
    return puncture_code(code1, code2)

def convert_to_decoding_form(bits):  # 0->-1, 1->1
    for cnt, i in enumerate(bits):
        bits[cnt] = Decimal(i) * 2 - 1

def equation_to_calculate_probability(m_k_1, x, Le, Lc, data, parity, value, state):  # Lx == Le/Lc
    code, next_state = return_code_and_next_state(value, state)
    #return m_k_1 + x*(Le/Lc)/Decimal('2') + (Lc/Decimal('2'))*((data*value) + (parity*code)), next_state
    return m_k_1 + value*(Le/Lc) + (Lc/Decimal('2'))*((data*value) + (parity*code)), next_state  # for DEBUG according to a reffered textbook

def decode(received_bits_data, received_bits_parity, loop_limit=1000, return_num_of_loop=False):
    ########## variables for decoding ##########
    Lc = 2
    # number of history. It may be needed to evaluate which length is suitable. (now 4)
    number_of_history = 4
    # limit of calculation loop.
    #loop_limit = 1000
    # print decoding result of every loop
    print_progress = False

    ##### for debugging #####
    if return_num_of_loop:
        num_of_loop = 0

    ########## convert str -> list ##########
    received_bits_data = list(received_bits_data)
    received_bits_parity = list(received_bits_parity)
    ########## convert to decoding form (0 -> -1, 1 -> 1) ##########
    convert_to_decoding_form(received_bits_data)
    convert_to_decoding_form(received_bits_parity)

    ########## convert each type of values to Decimal() ##########
    for cnt, i in enumerate(received_bits_data):
        received_bits_data[cnt] = Decimal(i)
    for cnt, i in enumerate(received_bits_parity):
        received_bits_parity[cnt] = Decimal(i)

    flag_coder = 0  # It switches coders. 0: coder1, 1: coder2
    if print_progress:
        print('received_bits_data:', ''.join([str((x+1)/2) for x in received_bits_data]))
        print('received_bits_parity:', ''.join([str((x+1)/2) for x in received_bits_parity]))

    #################### from here, loop for turbo decoding is started ####################
    #X = [Decimal('0') for x in range(len(received_bits_data))]  # Initial X
    X = [Decimal('-1') for x in range(len(received_bits_data))]  # Initial X
    Le = [Decimal('0') for x in range(len(received_bits_data))]  # Initial Le
    history_of_X = [len(received_bits_data)*'0' for y in range(number_of_history)]  # it stores latest four results.
    for number_of_loop in range(loop_limit):  # limit of calculation
        ##### for num_of_loop debugging #####
        num_of_loop = number_of_loop + 1

        if print_progress:
            print('\n##### loop', number_of_loop, '#####')

        ########## divide parity for two coders ##########
        if flag_coder:  # coder2
            received_bits_parity_divide = [x*(cnt%2) for cnt, x in enumerate(received_bits_parity)]  # [Decimal(...),...] -> [Decimal('0'), Decimal('2'), Decimal('0')]
        else:  #coder1
            received_bits_parity_divide = [x*((cnt%2)^1) for cnt, x in enumerate(received_bits_parity)]  # [Decimal('1'), Decimal('2'), Decimal('3')] -> [Decimal('1'), Decimal('0'), Decimal('3')]

        ########## calculate the most possible path by SOVA ##########
        num_of_state = 4
        metrics = [[[None, '', None, None] for y in range(4)] for x in range(len(received_bits_data) + 1)]  # metrics[position k][state(0-3), path, delta, update_sequence]
        metrics[0][0][0] = Decimal('0')  # m_0(0) == 0

        for k in range(len(received_bits_data)):  # k indicates a position
            for state in range(num_of_state):
                if metrics[k][state][0] != None:
                    for value in [Decimal('-1'), Decimal('1')]:
                        metric, next_state = equation_to_calculate_probability(
                                m_k_1=metrics[k][state][0], x=X[k], Le=Le[k], Lc=Lc, data=received_bits_data[k], parity=received_bits_parity_divide[k], value=value, state=state)
                        if metrics[k+1][next_state][0] != None:  # Previously calculated path is there.
                            metrics[k+1][next_state][3] = bin(int(metrics[k][state][1] + str(int((value+1)/2)), 2) ^ int(metrics[k+1][next_state][1], 2))[2:].rjust(k+1, '0')  # calculate update_sequence
                            if metrics[k+1][next_state][0] <= metric:
                                #metrics[k+1][next_state] = [metric, metrics[k][state][1] + str(int((value+1)/2)), metric - metrics[k+1][next_state][0]]  # I replaced it to improve readability.
                                metrics[k+1][next_state][2] = metric - metrics[k+1][next_state][0]  # calculate delta before updating of metrics[k+1][next_state][0]
                                metrics[k+1][next_state][0] = metric  # update metrics[k+1][next_state][0]
                                metrics[k+1][next_state][1] = metrics[k][state][1] + str(int((value+1)/2))

                            else:
                                metrics[k+1][next_state][2] = metrics[k+1][next_state][0] - metric
                        else:
                            #metrics[k+1][next_state] = [metric, metrics[k][state][1] + str(int((value+1)/2)), None]  # I replaced it to improve readability.
                            metrics[k+1][next_state][0] = metric
                            metrics[k+1][next_state][1] = metrics[k][state][1] + str(int((value+1)/2))

        # print metrics
        #for cnt, metric in enumerate(metrics):
        #    print(cnt, ':\n', metric)
        # print final metrics
        if print_progress:
            for cnt in range(num_of_state):
                print(cnt, ':', metrics[len(received_bits_data)][cnt])

            print('#'*30, '\n')

        # select the most possible path
        biggest_metric = [metrics[len(received_bits_data)][0][0], metrics[len(received_bits_data)][0][1]]
        balance_of_0_and_1 = None  # This variable indicates balance of 0 and 1. len(metric[1])==11, metric[1].count('1')==7 -> balance_of_0_and_1==1
        number_of_different_points = 0  # This variable indicates number of different points between metic[1] and previous calculated result. '111'and'100' -> num...==2
        for cnt, metric in enumerate(metrics[len(received_bits_data)]):
            if (biggest_metric[0] == metric[0]):
                ##### balance_of_0_and_1 #####
                tmp_balance_of_0_and_1 = int((Decimal( (len(metric[1])/2)+(len(metric[1])%2)-(metric[1].count('1')) )**2)**(Decimal(1/2)))
                if balance_of_0_and_1 != None:
                    if balance_of_0_and_1 > tmp_balance_of_0_and_1:
                        biggest_metric[0] = metric[0]
                        biggest_metric[1] = metric[1]
                        balance_of_0_and_1 = tmp_balance_of_0_and_1
                    elif balance_of_0_and_1 == tmp_balance_of_0_and_1:  # apply a value which is more different to previous X
                        ##### number_of_different_points #####
                        tmp_number_of_different_points = bin(int(''.join([str((x+1)/2) for x in X]),2)^int(metric[1],2)).count('1')
                        if number_of_different_points < tmp_number_of_different_points:
                            biggest_metric[0] = metric[0]
                            biggest_metric[1] = metric[1]
                            number_of_different_points = tmp_number_of_different_points

                else:  # first time (maybe when cnt==0)
                    # biggest_metric[0] = metric[0]
                    # biggest_metric[1] = metric[1]
                    balance_of_0_and_1 = tmp_balance_of_0_and_1

            elif (biggest_metric[0] < metric[0]):
                biggest_metric[0] = metric[0]
                biggest_metric[1] = metric[1]

        ########## ONLY FOR DEBUG ########## this setting came from a reffered textbook.
        #biggest_metric = [metrics[len(received_bits_data)][0][0], metrics[len(received_bits_data)][0][1]]  # for textbook
        ########################################

        #print('biggest_metric:', biggest_metric)
        X = [Decimal(biggest_metric[1][x])*2 - 1 for x in range(len(biggest_metric[1]))]
        if print_progress:
            print('X(01):', biggest_metric[1])
        #print('X', X)
        del biggest_metric

        biggest_state = []  # It holds state of X
        #print(X)
        return_path = generator_return_state(X)
        # get deltas and update_sequences by using return_path
        delta_and_update_sequence = list()
        for k in range(1, len(received_bits_data)+1):
            state = next(return_path)
            delta_and_update_sequence.append([metrics[k][state][2], metrics[k][state][3]])  # [delta, update_sequence]
            if delta_and_update_sequence[-1][1] != None:
                delta_and_update_sequence[-1][1] = metrics[k][state][3].ljust(len(received_bits_data), '0')
        del return_path

        # create a soft_output that is needed for next phase
        soft_output = list()
        for k in range(len(received_bits_data)):
            value = min([delta_and_update_sequence[x][0] for x in range(2, len(received_bits_data)) if (delta_and_update_sequence[x][1][k] == '1')])  # except 0<=k<=1 to avoid 'None'
            soft_output.append(X[k] * value)
        del value

        #print('soft_output:', soft_output)
        #print('X:', X)

        # calculate Le for the next SOVA
        for k in range(len(received_bits_data)):
            Le[k] = soft_output[k] - Le[k] - Lc * received_bits_data[k]  # for DEBUG according to a reffered textbook. It works fine.
            #Le[k] = soft_output[k] - Le[k]/Lc - Lc * received_bits_data[k]

        # interleave
        if flag_coder:  # coder2
            Le = interleaver(Le, 'deinterleave')
            received_bits_data = interleaver(received_bits_data, 'deinterleave')
            X = interleaver(X, 'deinterleave')
            ##### update history_of_X #####
            if print_progress:
                print('X(without interleave):', ''.join([str((x+1)/2) for x in X]))
            history_of_X.append(''.join([str((x+1)/2) for x in X]))
            history_of_X = history_of_X[1:]
        else:  # coder1
            Le = interleaver(Le, 'interleave')
            received_bits_data = interleaver(received_bits_data, 'interleave')
            ##### update history_of_X #####
            if print_progress:
                print('X(without interleave):', ''.join([str((x+1)/2) for x in X]))
            history_of_X.append(''.join([str((x+1)/2) for x in X]))
            history_of_X = history_of_X[1:]
            X = interleaver(X, 'interleave')

        flag_coder ^= 1  # switch coders. coder1 -> coder2, coder2 -> coder1
        #print('Le:', Le)

        for history in history_of_X:  # finish of decoding.
            if history_of_X[0] != history:
                break  # go to next loop
        else:
            break
        # if (history_of_X[0] == history_of_X[2]) & (history_of_X[1] == history_of_X[3]):  # finish of decoding. I'm not sure this is correct.
        #     break

    if return_num_of_loop:
        return history_of_X[-1], num_of_loop
    else:
        return history_of_X[-1]
